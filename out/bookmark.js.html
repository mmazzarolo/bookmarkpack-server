<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: bookmark.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: bookmark.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

var _ = require('lodash');
var async = require('async');
var Busboy = require('busboy');
var Promise = require('bluebird');
var request = Promise.promisifyAll(require('request'));
var cheerio = require('cheerio');

var User = require('../models/User');
var Bookmark = require('../models/Bookmark');

/**
 * GET user/bookmarks
 *
 * Get the bookmarks of the current user.
 *
 * @return {[bookmark]} body - An array with the bookmarks of the current user.
 */
 exports.getMyBookmarks = function(req, res, next) {
  console.log('-> getMyBookmarks');

  User.findById(req.me, '+bookmarks', function(err, user) {
    if (err) return next(err);
    if (!user) return res.status(404).send({ message: 'Unknown user.' });
    res.status(200).send(user.bookmarks).end();
  });
};

/**
 * POST user/bookmarks
 *
 * Add new bookmarks to the current user.
 *
 * @param {bookmark}/{[bookmark]} body - A single bookmark or an array of bookmarks.
 * @param {bookmark}/{[bookmark]} - The single updated bookmark or the array of updated bookmarks.
 */
 exports.postMyBookmarks = function(req, res, next) {
  console.log('-> postBookmarks');

  var reqBookmarks = [];
  var isReqArray = false;

  if (req.body.constructor === Array) isReqArray = true;

  if (isReqArray) {
    reqBookmarks = req.body;
  } else {
    reqBookmarks[0] = req.body;
  }

  for (var i = 0; i &lt; reqBookmarks.length; i++) {
    req.sanitize('url').trim().toString();
    req.assert('url', 'URL is required.').notEmpty();
    req.assert('url', 'Invalid URL.').isURL();
    req.assert('name', 'Invalid name.').optional().isClean();
    req.assert('name', 'Name must have less than 120 characters.').optional().isLength(0, 120);
    req.assert('notes', 'Notes must have less than 840 characters.').optional().isLength(0, 840);
    req.assert('hidden', 'Invalid hidden property.').optional().isBoolean();
    var errors = req.validationErrors();
    if (errors) return res.status(422).send({ message: 'Validation error.', errors: errors }).end();
  }

  addBookmarks(reqBookmarks, req.query.extract, req.user.id)
  .then(function(bookmarks) {
    if (isReqArray) {
      return res.status(200).send(bookmarks).end();
    } else {
      return res.status(200).send(bookmarks[0]).end();
    }
  })
  .catch(function (err) {
    return next(err);
  })

};

/**
 * PATCH user/bookmarks/
 *
 * Updates some bookmark info.
 *
 * @param {bookmark/[bookmark]} body - The properties of the bookmarks that must be updated.
 *                                     Every submitted bookmark must have an _id.
 * @return {bookmark} - The updated bookmark.
 */
 exports.patchMyBookmark = function(req, res, next) {
  console.log('-> patchBookmark');

  var extractTitle = (_.indexOf(req.query.extract, 'title') != -1);
  var extractFavicon = (_.indexOf(req.query.extract, 'favicon') != -1);

  var reqBookmarks = [];
  var resBookmarks = [];
  var isReqArray = false;

  if (req.body.constructor === Array) isReqArray = true;

  if (isReqArray) {
    reqBookmarks = req.body;
  } else {
    reqBookmarks[0] = req.body;
  }

  for (var i = 0; i &lt; reqBookmarks.length; i++) {
    req.sanitize('url').trim().toString();
    req.assert('_id', 'Malformed bookmark id.').isMongoId();
    req.assert('url', 'URL is required.').optional().notEmpty();
    req.assert('url', 'Invalid URL.').optional().isURL();
    req.assert('name', 'Invalid name.').optional().isClean();
    req.assert('name', 'Name must have less than 120 characters.').optonal().len(0, 120);
    req.assert('notes', 'Notes must have less than 840 characters.').optional().len(0, 840);
    req.assert('hidden', 'Invalid hidden property.').optional().isBoolean();
    var errors = req.validationErrors();
    if (errors) return res.status(422).send({ message: 'Validation error.', errors: errors }).end();
  }

  User.findById(req.user.id, function(err, user) {
    if (err) return next(err);

    async.each(reqBookmarks, function(reqBookmark, complete) {

      console.log(reqBookmark);
      if (!reqBookmark._id) {
        return res.status(400).send({ message: 'One or more of the submitted bookmarks have no _id' }).end();
      }

      extractFromUrl(reqBookmark.url, extractTitle, extractFavicon, function(err, results) {
        if (err) return next(err);
        var updBookmark = user.bookmarks.id(reqBookmark._id);
        updBookmark.name = reqBookmark.name || results.title || updBookmark.name;
        updBookmark.url = reqBookmark.url || updBookmark.url;
        updBookmark.favicon = results.favicon || updBookmark.favicon;
        updBookmark.tags = reqBookmark.tags || updBookmark.tags;
        resBookmarks.push(updBookmark);
        complete();
      });

    }, function(err) {
      if (err) return next(err);
      user.save(function(err) {
        if (err) return next(err);
        if (isReqArray) {
          res.status(200).send(resBookmarks).end();
        } else {
          res.status(200).send(resBookmarks[0]).end();
        }
      });
    });
  });
};

/**
 * DELETE user/bookmarks/
 *
 * Delete one or more bookmarks.
 *
 * @param {bookmark/[bookmarks]} body - The id or an array of id of the bookmarks to delete.
 */
 exports.deleteMyBookmark = function(req, res, next) {
  console.log('-> deleteBookmark');

  var reqBookmarks = [];

  if (req.body.constructor === Array) {
    reqBookmarks = req.body;
  } else {
    reqBookmarks[0] = req.body;
  }

  User.findById(req.user._id, function(err, user) {
    if (err) return next(err);

    async.each(reqBookmarks, function(bookmark, complete) {
      user.bookmarks.id(bookmark._id).remove();
      complete();
    }, function(err) {
      if (err) return next(err);
      user.save(function(err) {
        if (err) return next(err);
        res.status(200).end();
      });
    });
  });
};

/**
 * POST user/bookmarks/import
 *
 * Adds the exported bookmarks to the current user.
 *
 * @param {file} - Bookmarks exported in HTML format.
 */
 exports.postImport = function(req, res, next) {
  console.log('-> postImport');

  var html = '';
  var bookmarks = [];
  var busboy = new Busboy({
    headers: req.headers,
    limits: { files: 1, fileSize: 1000000 }
  });

  busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {
    console.log('File [' + fieldname + ']: filename: ' + filename + ', encoding: ' + encoding + ', mimetype: ' + mimetype);
    if (mimetype != 'text/html') {
      req.unpipe(busboy);
      res.writeHead(400, { 'Connection': 'close', 'Content-Type': 'application/json' });
      res.write(JSON.stringify({ 'message' : 'Wrong input file.' }));
      res.end();
      return;
    }
    file.on('data', function(data) {
      console.log('File [' + fieldname + '] got ' + data.length + ' bytes');
      html += data.toString();
    });
    file.on('limit', function() {
      console.log('Limit reached!');
      req.unpipe(busboy);
      res.writeHead(400, { 'Connection': 'close', 'Content-Type': 'application/json' });
      res.write(JSON.stringify({ 'message' : 'The uploaded file is too big for being processed.' }));
      res.end();
      return;
    });
    file.on('end', function() {
      var $ = cheerio.load(html);
      $('A').each(function(i, elem) {
        var url = $(this).attr('href');
        var name = $(this).text();
        var favicon = $(this).attr('icon');
        bookmarks.push({
          'url' : url,
          'name' : name,
          'favicon' : favicon,
        });
      });

      console.log('File [' + fieldname + '] Finished');
    });
  });
  busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated) {
    console.log('Field [' + fieldname + ']: value: ' + inspect(val));
  });
  busboy.on('finish', function() {
    console.log('Done parsing form!');
    addBookmarks(bookmarks, false, false, req.user.id, function(err, results) {
      if (err) return next(err);
      return res.status(200).send(results).end();
    })
  });
  req.pipe(busboy);
};


/**
 * POST user/bookmarks/github
 *
 * Adds the GitHub starred repositories from the specified username.
 *
 * @param {string} body.username - The GitHub username of the owner of the starred repositories to import.
 */
 exports.postGithub = function(req, res, next) {
  console.log('-> postGithub');

  var re = new RegExp('^[A-Z0-9_]*$', 'i');
  if (typeof(req.body.username) != 'string' || !re.test(req.body.username))
    return res.status(400).send({ message: 'Invalid username' }).end();

  var newBody = [];
  var githubUrl = 'https://api.github.com/users/' + req.body.username + '/starred'

  async.waterfall([
    // Extract GitHub favicon
    function(done) {
      extractFaviconFromUrl('https://github.com', done);
    },
    // API call to GitHub to get the starred repos
    function(favicon, done) {
      var options = {
          url: githubUrl,
          method: 'GET',
          headers: {'user-agent': 'node.js'}
      };
      request(options, function (err, response, body) {
        if (response.statusCode != 200) {
          return res.status(404).send({ message: 'User not found' }).end();
        }
        done(err, favicon, JSON.parse(body));
      });
    },
    // Prepare the bookmarks array
    function(favicon, repos, done) {
      var bookmarks = [];
      async.each(repos, function(repo, complete) {
        var url = repo.html_url;
        var name = repo.name;
        var favicon = favicon;
        bookmarks.push({
          'url' : url,
          'name' : name,
          'favicon' : favicon
        });
        complete();
      }, function(err) {
        if (err) return next(err);
        return done(null, bookmarks);
      });
    },
    // Add the bookmarks
    function(bookmarks, done) {
      addBookmarks(bookmarks, false, false, req.user.id, done);
    }
  ], function(err, results) {
    if (err) return next(err);
    res.status(200).send(results).end();
  });

};

/**
 * Adds the input bookmarks to the current user.
 *
 * @param {[bookmark]} bookmarks - The array of bookmarks to add.
 * @param {boolean} extractTitle - Extract the title?
 * @param {boolean} extractFavicon - Extract the favicon?
 * @param {string} userId - Id of the current user.
 * @callback {function} done - Callback.
 */
var addBookmarks = Promise.promisify(function (bookmarks, extract, userId, done) {
  console.log('-> addBookmarks');
  User.findById(userId, '+bookmarks').exec()
  .then(function(user) {
    console.log(user.email);
    return Promise.each(bookmarks, function(bookmark) {
      parseBookmark(bookmark, user, extract);
    })
    .then(function() {
      console.log('save');
      return user.save();
    })
  })
  .then(function(user) {
    return done(null, user.bookmarks);
  })
  .catch(function(err) {
    console.log("Error reading file", e);
    // return done(err);
  })
});

var parseBookmark = function(bookmark, user, extract) {
  return Promise.join(
    extractTitleFromUrl(bookmark.url, extract),
    extractFaviconFromUrl(bookmark.url, extract),
    function(title, favicon) {
      var newBookmark = new Bookmark({
        url: bookmark.url,
        name: bookmark.name || title,
        favicon: bookmark.favicon || favicon,
        hidden: bookmark.hidden,
        notes: bookmark.notes
      });
      console.log('then');
      console.log(newBookmark.name);
      user.bookmarks.push(newBookmark);
    }
  )
};

// Extracting the title from the page
var extractTitleFromUrl = Promise.promisify(function(url, extract, done) {
  var stream = '';
  var re = new RegExp('&lt;title>(.*?)&lt;/title>', 'i');
  var title;

  if (_.indexOf(extract, 'title') != -1) {
    request.get({ url: url })
    .on('data', function(data) {
      stream = stream + data;
      var match = stream.match(re);
      if (match) {
        title = match[1];
        this.abort();
      }
    })
    .on('end', function(data) {
      return done(null, title);
    });
  } else {
    done (null, title);
  }
});

// Extracting the favicon from the url
var extractFaviconFromUrl = Promise.promisify(function(url, extract, done) {
  var faviconUrl =  unescape('http://www.google.com/s2/favicons?domain=' + url);
  var favicon;

  if (_.indexOf(extract, 'favicon') != -1) {
    request({ uri: faviconUrl, encoding: 'binary' }, function (err, response, body) {
      if (!err &amp;&amp; response.statusCode == 200) {
        var type = response.headers['content-type'];
        var prefix = 'data:' + type + ';base64,';
        var image = new Buffer(body.toString(), 'binary').toString("base64");
        favicon = prefix + image;
      }
      done(err, favicon);
    });
  } else {
    done (null, favicon);
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#createJWT">createJWT</a></li><li><a href="global.html#deleteAccount">deleteAccount</a></li><li><a href="global.html#deleteMyBookmark">deleteMyBookmark</a></li><li><a href="global.html#getAccount">getAccount</a></li><li><a href="global.html#getMe">getMe</a></li><li><a href="global.html#getMyBookmarks">getMyBookmarks</a></li><li><a href="global.html#getUser">getUser</a></li><li><a href="global.html#patchAccount">patchAccount</a></li><li><a href="global.html#patchMyBookmark">patchMyBookmark</a></li><li><a href="global.html#postEmail">postEmail</a></li><li><a href="global.html#postFacebook">postFacebook</a></li><li><a href="global.html#postGithub">postGithub</a></li><li><a href="global.html#postGoogle">postGoogle</a></li><li><a href="global.html#postImport">postImport</a></li><li><a href="global.html#postLogin">postLogin</a></li><li><a href="global.html#postMyBookmarks">postMyBookmarks</a></li><li><a href="global.html#postPassword">postPassword</a></li><li><a href="global.html#postReset">postReset</a></li><li><a href="global.html#postResetConfirm">postResetConfirm</a></li><li><a href="global.html#postSignup">postSignup</a></li><li><a href="global.html#postUnlink">postUnlink</a></li><li><a href="global.html#postVerify">postVerify</a></li><li><a href="global.html#postVerifyConfirm">postVerifyConfirm</a></li><li><a href="global.html#username">username</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Oct 29 2015 20:09:16 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
